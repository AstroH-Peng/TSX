#!usr/bin/env python
# -*- coding: utf-8 -*-
#Modified date: 18/05/2016
#Nima 
#

import numpy as np
import scipy as sp

import PyKEP as pk

import config
import tensor_constructor

class Propagator:
    """Class devoting to the trajectory propation.

    Attributes defined here:
    -none

    Methods define here:
    -rate_function(): gives the rate of the evaluated function respects to 
    the position and velocity vectors
    -rk4(): computes the Runge-Kutta order 4 numerical integration method.

    """
    def __init__(self):
        """Constructor of class Propagator."""
        self.h_min = config.time_step_min
        self.h_max = config.time_step_max
    def rate_function(self, date, pos_vel):
        """Method providing the acceleration(s) undergone by the spacecraft
        from space bodies like Sun, planets, asteroids... and from dissipative
        forces like solar radiation pressure, magnetic field... to be integrated 
        in order to return new both position and velocity vectors.
        """
        ts = tensor_constructor.AccelConstructor()
        pos = pos_vel[0:3]
        vel = pos_vel[3:6]
        acc = ts.get_sum_acceleration(date*pk.SEC2DAY, pos)
        acc = np.array([acc[0][0], acc[1][1], acc[2][2]])
        acc = acc - pk.MU_SUN*pos/(np.linalg.norm(pos)**3)
        return np.append(vel, acc)
    def rk4(self, date, pos_vel, h):
        """Method computing the Runge-Kutta order 4 numerical integration 
        method to estimate new position of spacecraft trajectory.
        """
        #half_step_time = step_time / 2

        k1 = h * self.rate_function(date, pos_vel)
        k2 = h * self.rate_function(date + h/2, pos_vel + k1/2)
        k3 = h * self.rate_function(date + h/2, pos_vel + k2/2)
        k4 = h * self.rate_function(date + h, pos_vel + k3)

        next_pos_vel = pos_vel + 1./6*(k1 + 2*k2 + 2*k3 + k4)
        return next_pos_vel
    def rkf45(self, date, pos_vel, h):
        """Complete the Runge-Kutta-Fehlberg numerical integration method 
        by using an adaptive step time control during the computation.
        """ 
        tolerance = 1.0E-6
        #h_min = h / 64
        #h_max = 64 * h
        n = len(pos_vel)
        #print "n: ", n
        print ("h: ", h)
        print ("h_min: ", self.h_min)
        print ("h_max: ", self.h_max)
        k1 = h * self.rate_function(date, pos_vel)
        k2 = h * self.rate_function(date + h/4, pos_vel + k1/4)
        k3 = h * self.rate_function(date + 3/8*h, pos_vel + 3/32*k1 + 9/32*k2)
        k4 = h * self.rate_function(date + 12/13*h, pos_vel + 1932/2197*k1 - 7200/2197*k2 + 7296/2197*k3)
        k5 = h * self.rate_function(date + h, pos_vel + 439/216*k1 - 8*k2 + 3680/513*k3 - 845/4104*k4)
        k6 = h * self.rate_function(date + 1/2*h, pos_vel - 8/27*k1 + 2*k2 - 3544/2565*k3 + 1859/4104*k4 - 11/40*k5)

        next_pos_vel = pos_vel + 25/216*k1 + 1408/2565*k3 + 2197/4104*k4 - 1/5*k5
        tild_pos_vel = pos_vel + 16/135*k1 + 6656/12.825*k3 + 28.561/56.430*k4 - 9/50*k5 + 2/55*k6

        estimate_error = np.fabs(tild_pos_vel - next_pos_vel) 
        print ("estimate_error: ", estimate_error)
        mean_estimate_error = np.sqrt(sum(estimate_error**2) / n)
        print ("mean_estimate_error: ", mean_estimate_error)
        delta = 0.8408 * ((tolerance * h) / mean_estimate_error)**(0.25)  
        
        #if mean_estimate_error <= tolerance: #and h < self.h_max:
            #pos_vel = pos_vel + 16/135*k1 + 6656/12.825*k3 + 28.561/56.430*k4 - 9/50*k5 + 2/55*k6
            #h = h * 2
            #date = date + h
        #if mean_estimate_error > tolerance: #and h > self.h_min:
            #pos_vel = pos_vel + 16/135*k1 + 6656/12.825*k3 + 28.561/56.430*k4 - 9/50*k5 + 2/55*k6
            #h = h / 2
        #else:
            #pos_vel = next_pos_vel
        #print ("val4: ", next_pos_vel)
        #print ("val5: ", tild_pos_vel)
        #print ("error: ", estimate_error)
        print ("delta: ", delta)
        if h < self.h_min:
            h = self.h_min
        if h > self.h_max:
            h = self.h_max
        if delta < 0.75 and h > 2*self.h_min:
            pos_vel = next_pos_vel
            h = h/2
        elif delta > 1.50 and 2*h < self.h_max:
            pos_vel = next_pos_vel
            h = 2*h
        else:
            pos_vel = tild_pos_vel
        print ("hnext: ", h)    
        return h, pos_vel
     


